<link rel="stylesheet" type="text/css" href="../style.css"/>
<meta charset="UTF-8">
<title>Just another imperfect language</title>
<h1>Just another imperfect language.</h1>

<h3>Motivation:</h3>
<p>Everything seems so easy in my mind, until I have to write it down.</p>
<p>Putting thoughts on paper is much harder but it does not compare to writing them as a program.</p>
<p>Although C is fine for writing efficient programs it is not useful as thinking tool.<br/>
Python is better as thinking tool but is dynamically typed.<br/>
Haskell is too restrictive as is often common for functional languages.<br/>
Lisp is hard to work with for system applications.<br/>
Idris is a bit to functional for all purposes.<br/>
Finally, Rust does not support user definable operators.<br/>
<p>The simplest solution is to create new language.</p>

<h3>Specifications:</h3>
<ul>
<li>Easy problems must stay easy, hard problems must become easy.</li>
<li>No handicaps for good programmers.</li>
<li>Easy for beginners.</li>
<li>Readable and expressive code.</li>
<li>All compiler options important for code meaning must be present in code before the main.</li>
<li>User definable operators and their precedence, with ability to turn them off.</li>
<li>User definable notations.</li>
<li>User definable symbols.</li>
<li>Redefinable keywords.</li>
<li>Unicode support.</li>
<li>Algebraic data types.</li>
<li>Type classes.</li>
<li>Data dependent types.</li>
<li>Ability to force safe code on parts or on whole program.</li>
<li>Ability to use C bindings, and therefore ASM.</li>
<li>Partial application.</li>
<li>Compile time definitions and macros.</li>
<li>Ability to prove stuff about code for better optimizations or simplifications.</li>
<li>Captures and quarantines.</li>
</ul>
